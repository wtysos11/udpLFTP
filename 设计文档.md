测试代码
```python
import os
os.chdir("E:\\code\\作业\\计算机网络\\mid_term")
```

## 功能描述

1. 实现客户端向服务端发送大文件
2. 客户端从服务器端接受大文件

## 要求：

1. 使用CS模型
2. LFTP使用UDP作为基本协议，但是要实现和TCP一样100%可靠。
3. 实现流控制和阻塞控制
4. 服务端具有同时服务多个客户端能力。
5. LFTP需要提供有意义的调试信息

## 实现原理

### 可靠数据传输协议
P138

自动重传请求协议(ABQ)
rdt3.0 比特交替协议

流水线P147
选择重传
发送方的事件与动作：
1. 从上层收到数据。当从上层收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在GBN中一样，要么将数据缓存，要么将其返回给上层以便以后传输。
2. 超时。定时器再次被用来防止丢失分组。然而，现在每个分组都必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。可以使用单个硬件定时器模拟多个逻辑定时器的操作。
3. 收到ACK。如果收到ACK，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。

SR接收方将确认一个正确接受的分组，不管它是否失序。失序的分组将被缓存直到所有丢失分组（即序号更小的分组）皆被收到为止，这时才可以将一批分组按序交给上层。
接收方的事件与动作：
1. 序号在\[rcv_base,rcv_base+N-1\]内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。如果该分组以前没有收到过，则缓存该分组。如果该分组的序号等于接受窗口的基序号rcv_base，则将该分组以及之前缓存的序号连续的分组交付给上层。然后，接受窗口按向前移动分组的编号向上交付这些分组。
2. 序号在\[rcv_base - N,rcv_base -1\]内的分组被正确收到。在此情况下，必须产生一个ACK，即使该分组时接收方以前收到的分组。
3. 其他情况：忽略该分组。

注意：发送方和接收方并不总是能够看到相同的结果。接受方的2动作是为了防止出现如发给发送方的ACK中途丢失的情况。
注意2：有限序号范围内，发送方和接收方窗口缺乏同步会导致严重的后果。这时候应该有窗口大小小于或等于序号空间大小的一半，不然很可能会出现错误。

### 流量控制

TCP让发送方来维护一个接受窗口的变量(Receive window)，接受窗口用来给发送方一个指示：该接收方还有多少剩余的缓存空间。
定义如下变量：LastByteRead：接收方从缓存中读取出的数据流的最后一个字节的编号。LastByteRcvd：从网络中到达并且已经放入缓存中的最后一个字节的编号。
显然LastByteRcvd-LastByteRead <= Receive window
剩余空间rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)

接收方通过将rwnd放入报文头中来通知发送方自己的剩余空间大小。发送方不能发出超过接收方剩余空间大小的流。
假如接收方的rwnd=0，那么接收方仍然要不断向发送方发送rwnd=0的头来维持连接。

### 拥塞控制

发送方维护一个拥塞窗口cwnd，一个发送方中未确认的数据量不会超过cwnd与rwnd的最小值
即`LastByteSent-LastByteAcked <= min{cwnd,rwnd}`
1. 慢启动：cwnd的值通常设置为一个MSS（最大报文长度）的较小值，收到一个报文，确认一次后就并行加一个MSS
2. 阻塞避免：ssthresh = cwnd/2(发送阻塞的时候)，如果下一次超过ssthresh，则进入线性增加阶段（收到之后增加一个报文段）
3. 如果检测到3次重复的ACK，进入快速恢复阶段。

## 设计

服务端主进程：
    收到客户端发来的连接请求 SYN = 1，里面包含下载或上传请求以及文件名称
    如果文件不存在或者非法，拒绝。不然，建立新的socket，向客户端回复，客户端必须回复，不然反复发送。
    收到客户端回复后，打开新的进程准备与客户端的通信（下载或上传）。如果打开进程失败，向客户端发送连接失败FIN。

服务端分线程或客户端发送线程：
    该线程实现100%可靠的数据传输
准备：
1. 分包。使用文件指针读取文件，准备从文件中读取来获得包。
2. 设置各个变量，包括发送端缓存区大小、接收端缓存区大小。阻塞窗口与序号空间大小。
3. 准备缓冲区，根据缓冲区的申请情况调节各个值。

发送：
    实现阻塞控制、流量控制。
    状态机模型：SR模型
    两边维护一个四个集合，来进行检查

包计时器系统：
    每个包发送的时候获得当前系统时间，每次轮询的时候检查所有包（优先队列优化），如果超时，则重传。收到ACK后将其删除。

实际运行：
使用Queue.Queue在线程间传递数据。
发送端
    发送一个包，记录正在等待的包的数量。
    在正在等待的包的数量小于阈值的时候，收到一个包就发两个包。达到或超过阈值的时候，收到一组包就发送一个包（窗口前移）
    轮询，使用优先队列维护包的发送时间，对发送时间最小的包开始检查，如果超时了，重新发送，并且重置阈值和阻塞窗口。
    
接受线程：收到之后将收到的数据放入Queue中

接收端：
    收到包之后发送ACK，伺机移动窗口。
    向上层应用传递数据：往文件内append二进制数据。

## 小实验

对某些知识不是特别清楚，设计几个小实验验证一下想法。

1. 多线程间通信实验。
验证：Queue的读取是否是阻塞的，如果读写。
线程最多可以开多少个，如果发生了错误怎么处理。
文件如何append，如果发生错误如何处理。（打开失败，写入空间不足）

2. 网络传输实验：
接受线程和发送线程之间的互动问题：
    接受线程收到数据之后如何传送给发送线程。
    接受线程收到结束信号之后如何关闭发送线程
    主线程如何管理接受线程和发送线程。
 
实验1，验证Queue.Queue的读写
    对于一个网络服务端A，运行一个发送服务端A2，接受服务端A3。
    当接受服务端接受到数据的时候，会将数据放入到发送服务端A2内。
        发送服务端使用Queue.get来拿到数据，如果没有收到数据，每10s钟输出一次，计时器使用轮询查阅。
结果：Queue的put和get是阻塞的

解决方案：每隔一段时间，主进程向服务端接受方发送空的数据头，更新。
主要目的是检查是重发与超时断连（应该为超时重发的2倍左右，超时断连的一半）
Queue
通过设置block = False可以进行非阻塞通信（需要对get处理queue.Empty错误，对put处理queue.Full错误）
通过设置timeout可以设置超时

注意：python3中Queue更名为queue

实验2，文件读写：
对于给定的二进制流，如何进行append型的读写
使用open("filename","ab")(二进制形式append)，如果没有则创建，有的话会在后面附带。

3. socket绑定问题
多次绑定会引起OSError
errors related to socket or address semantics raise OSError or one of its subclasses

## 头部设计
首部长度 8位
SYN 32位
ACK 32位
接受窗口 16位
状态码
需要参数：
    

## 计划设计

v1.0 制作基于rdt3.0的客户端，采用主从式结构，实现流控制，不实现其他功能。
要求：
1. 停等。
2. 多线程，支持同时多个客户端
3. 支持上传和下载
4. 支持重传
5. 一个包一个包的发过去


v2.0 加入流水线
1. 加入活动窗口
2. 每次发送包的数量是根据缓存区大小决定的。

v3.0 加入阻塞控制
1. 加入慢启动

## 具体实现
### 具体过程

建立连接：
服务端运行
客户端向服务端发送上传/下载请求
服务端向客户端发送运行端口（接受端口、发送端口），并申请线程，如果申请线程失败或其他原因失败，会向客户端发送失败原因。
客户端向服务端发送准备接受完毕请求。如果没有准备完毕，会收到终止请求。
#### v1.0
连接建立完毕：双方使用包装头进行交互
    先实现rdt3.0，比特交替协议（4）
    发送方准备包，向接收方发送，准备计时器
    接收方收到包后发送ACK回去。
        发送方等待ACK，如果ACK一直没有收到，就会重发。
#### v2.0
进行SR协议。
发送固定数量的包出去，保证包的数量不超过对面的缓存区的情况下尽量多的发送。设置窗口。

#### v3.0
实现阻塞控制，从1到爆

### 具体过程


1. 实现动态下载
客户端给服务端发送为文件名
服务端收到文件名后开始读写文件，并第一次发送
服务端每次在收到客户端传回的ACK后进行再次发送直到文件终止
客户端收到输入后直接显示在屏幕上。

接受线程、发送线程和主线程分离
关键在于线程分离之后recvfrom能否正常工作。

v1.5：实现头文件传输与解析

2. 实现rdt3.0可靠数据传输

3. 实现SR传输
   
4. 实现上传


### 辅助函数
#### myHead

实现了对网络头的简易封装以及对于Options的写入。
网络头：
SYN 32位
ACK 32位
接受窗口 16位
FIN SYN ACK 空 4位标记
可选项长度 8位
可选项内容
剩余的为：
包数据内容

### 服务端
#### 主线程

时刻保持对默认端口(mainport)的监听。

如果收到服务端Get的请求，   