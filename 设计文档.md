## 功能描述

1. 实现客户端向服务端发送大文件
2. 客户端从服务器端接受大文件

## 要求：

1. 使用CS模型
2. LFTP使用UDP作为基本协议，但是要实现和TCP一样100%可靠。
3. 实现流控制和阻塞控制
4. 服务端具有同时服务多个客户端能力。
5. LFTP需要提供有意义的调试信息

## 实现

### 可靠数据传输协议
P138

自动重传请求协议(ABQ)
rdt3.0 比特交替协议

流水线P147
选择重传
发送方的事件与动作：
1. 从上层收到数据。当从上层收到数据后，SR发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送；否则就像在GBN中一样，要么将数据缓存，要么将其返回给上层以便以后传输。
2. 超时。定时器再次被用来防止丢失分组。然而，现在每个分组都必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。可以使用单个硬件定时器模拟多个逻辑定时器的操作。
3. 收到ACK。如果收到ACK，倘若该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组，则发送这些分组。

SR接收方将确认一个正确接受的分组，不管它是否失序。失序的分组将被缓存直到所有丢失分组（即序号更小的分组）皆被收到为止，这时才可以将一批分组按序交给上层。
接收方的事件与动作：
1. 序号在\[rcv_base,rcv_base+N-1\]内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。如果该分组以前没有收到过，则缓存该分组。如果该分组的序号等于接受窗口的基序号rcv_base，则将该分组以及之前缓存的序号连续的分组交付给上层。然后，接受窗口按向前移动分组的编号向上交付这些分组。
2. 序号在\[rcv_base - N,rcv_base -1\]内的分组被正确收到。在此情况下，必须产生一个ACK，即使该分组时接收方以前收到的分组。
3. 其他情况：忽略该分组。

注意：发送方和接收方并不总是能够看到相同的结果。接受方的2动作是为了防止出现如发给发送方的ACK中途丢失的情况。
注意2：有限序号范围内，发送方和接收方窗口缺乏同步会导致严重的后果。这时候应该有窗口大小小于或等于序号空间大小的一半，不然很可能会出现错误。

### 流量控制

TCP让发送方来维护一个接受窗口的变量(Receive window)，接受窗口用来给发送方一个指示：该接收方还有多少剩余的缓存空间。
定义如下变量：LastByteRead：接收方从缓存中读取出的数据流的最后一个字节的编号。LastByteRcvd：从网络中到达并且已经放入缓存中的最后一个字节的编号。
显然LastByteRcvd-LastByteRead <= Receive window
剩余空间rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)

接收方通过将rwnd放入报文头中来通知发送方自己的剩余空间大小。发送方不能发出超过接收方剩余空间大小的流。
假如接收方的rwnd=0，那么接收方仍然要不断向发送方发送rwnd=0的头来维持连接。

### 拥塞控制

发送方维护一个拥塞窗口cwnd，一个发送方中未确认的数据量不会超过cwnd与rwnd的最小值
即`LastByteSent-LastByteAcked <= min{cwnd,rwnd}`
1. 慢启动：cwnd的值通常设置为一个MSS（最大报文长度）的较小值，收到一个报文，确认一次后就并行加一个MSS
2. 阻塞避免：ssthresh = cwnd/2(发送阻塞的时候)，如果下一次超过ssthresh，则进入线性增加阶段（收到之后增加一个报文段）
3. 如果检测到3次重复的ACK，进入快速恢复阶段。